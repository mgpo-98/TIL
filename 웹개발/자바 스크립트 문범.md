# 자바 스크립트 문범

- let

  ``` javascript
  <--! 재할당 가능-->
  let numver = 10 //1. 선언 및 초기값 할당
  number = 10 //2. 재할당
  console.log(number) // 10 
  
  <--!재선언 불가능-->
  let number = 10 //1. 선언 및 초기값 할당
  let number = 50 //2. 재선언 불가능
  ```



- const

  ``` javascript
  <--!재할당 불가능-->
  const number = 10 //1.선언 및 초기값 할당
  number = 10 //2. 재할당 불가능
  
  <--!재선언 불가능 -->
  const number = 10 //1. 선언 및 초기값 할당
  const number = 50 //2. 재선언 불가능
  ```

  

- 블록 스코프(block scope)

  - if, for, 함수 등의 중괄호 내부를 가리킴

  - 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능

    ```javascript
    let x = 1
    if (x == 1){
    	let x = 2
        console.log(x) //2
    }
    console.log(x) //1
    
    ```

- var

  - var로 선언한 변수는 재선언 및 재할당 모두 가능

  - ES6 이전에 변수를 선언할 때 사용되던 키워드

  - 호이스팅 되는 특성으로 인해 예기치 못한 문제 발생 가능

    ```javascript
    var number = 10 //1. 선언 및 초기값 할당
    var number = 50 //2. 재할당
    console.log(number) //50
    ```

    - 함수 스코프 

      - 함수의 중괄호 내부를 가르킴

      - 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가능

        ``` javascript
        function foo(){
            var x = 5
            console.log(x) //5
        }
        console.log(x)
        ```

   -	호이스팅
     -	변수를 선언 이전에 참조할 수 있는 현상
     -	변수 선언 이전의 위치에서 접근 시 undefined를 반환
     -	자바스크립트는 모든 선언을 호이스팅 한다.

### 자료형

- 자료형은 컴표터가 처리하는 자료의 형태

- JavaScript 의 모든 값은 특정한 데이터 타입을 가짐

- 특징

  - 느슨한 자료형 체크(weak datatype check)
  - 자바스크립트는 미리 변수의 자료형을 지정하지 않음
  - 변수를 지정하고 원하는 값을 할당만 하면 됨

- 종류

  - 기본형,원시타입(Primitive type)

    > 객체가 아닌 기본타입 : 변수에 해당 타입의 값이 담기며 다른 변수에 복사할 때 실제 값이 복사됨

    - 숫자(number) : 따옴표 없이 표기한 숫자
    - 문자열(string) : 작은 따옴표(')나 큰 따옴포(")로 묶어 나타냄
    - 논리형(boolean) : 참(true)/거짓(false)란 두 값만 가지고 있는 유형
    - undefined : 변수를 선언하고 값을 저장하지 않는 등의 자료형을 지정하지 않았을 때.
    - null : 값이 유효하지 않을 때

  - 복합형,참조타입(Reference type)

    > 객체 타입의 자료형 : 변수에 해당 객체의 참조 값이 담기며 다른 변수에 복사할 때 참조 값이 복사됨

    - 배열(array) : 하나의 변수에 여러 값을 저장하는 유형
    - 객체(object) : 함수의 속성이 함께 포함된 유형

**숫자형**

- 정수, 실수 구분없는 하나의 숫자 타입

- 부동소수점 형시을 따름

  ```
  const a = 13         // 양의 정수
  const b = -5         // 음의 정수
  const c = 3.14       // 실수
  const d = 2.998e8    // 거듭제곱
  const e = Infinity   // 양의 무한대
  const f = -Infinity  // 음의 무한대
  const g = NaN        // 산술 연산 불가
  ```

- 정수

  - 소수점 없는 숫자
  - 표현 방법에 따라 10진수, 8진수, 16진수

- 실수

  - 소수점이 있는 숫자
  - 자바스크립트에서는 정밀한 실수 계산을 못 함

- NaN(Not-A-Number)

  - 계산 불가능한 경우 반환되는 값

**문자형**

- 텍스트 데이터를 나타내는 타입

- 작은 따옴표(‘ ‘) 나 큰 따옴표(“ “)로 묶은 자료

- 숫자도 따옴표로 묶으면 문자형이 됨

- 16bit 유니코드 문자의 집합

- 따옴표 안에 따옴표를 넣어야 할 경우 ‘ ＂ ＂ ‘, 또는 ＂ ‘ ‘＂ 처럼 사용

  ```
  const firstName = 'Brandon';
  const lastName = 'Elch';
  const fullName = '${firstName} ${lastName}'
  ```

> 문자열 관련 메서드

- string.includes(value);
  - 문자열에 value가 존재하는지 판별 후 참/거짓 반환
- string.split(value);
  - value가 없을 경우, 기존 문자열을 배열에 담아 반환
  - value가 빈 문자열일 경우 각 문자로 나눈 배열을 반환
  - value가 기타 문자열일 경우, 해당 문자열로 나눈 배열을 반환
- string.replace(from, to)
  - 문자열에 from 값이 존재할 경우, 1개만 to 값으로 교체하여 반환
- string.replaceAll(from, to)
  - 문자열에 from 값이 존재할 경우, 모두 to 값으로 교체하여 반환
- string.trim()
  - 문자열 시작과 끝의 모든 공백문자(스페이스, 탭, 엔터 등)를 제거한 문자열 반환
- string.trimStart()
  - 문자열 시작의 공백문자(스페이스, 탭, 엔터 등)를 제거한 문자열 반환
- string.trimEnd()
  - 문자열 끝의 공백문자(스페이스, 탭, 엔터 등)를 제거한 문자열 반환

### 연산자

- 할당 연산자(복합대입연산자)
  - 변수에 값을 할당하는 연산자
  - 사칙 연산자와 조합해서 사용할 수 있음

| 할당 연산자 응용 | 예     | 의미      |
| ---------------- | ------ | --------- |
| +=               | a += b | a = a + b |
| -=               | a -= b | a = a - b |
| *=               | a *= b | a = a * b |
| /=               | a /= b | a = a / b |
| %=               | a %= b | a = a % b |

- 연결 연산자

  - 문자열과 문자열을 + 기호를 사용해 연결

- 동등 비교 연산자(==)

  - 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환
  - 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교
  - 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
  - 예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고 사용하지 않음

- 일치 비교 연산자(===)

  - 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환
  - 엄격한 비교(두 비교 대상의 타입과 값 모두 같은지 비교)가 이뤄지며 암묵적 타입 변환이 발생하지 않음

- 논리 연산자

  - and/or/not

    - and >> &&
    - or >> ||
    - not >> !

  - 단축평가 지원

    > false && true => false
    >
    > true || false => true

- 삼항 연산자(Ternary Operator)

  - 세 개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자

  - 가장 왼쪽의 조건식이 참이면 콜론(:) 앞의 값을 사용하고 그렇지 않으면 콜론(:) 뒤의 값을 사용

  - 삼항 연산자의 결과 값이기 때문에 변수에 할당 가능

    ```
    console.log(true ? 1 : 2);  // 1
    console.log(false ? 1 : 2); // 2
    
    const result = Math.PI > 4 ? 'Yes' : 'No';
    console.log(result); // No
    ```

- 형변환

  - 숫자형과 문자형을 더하면 숫자를 문자열로 인식함
  - 곱하기나 나누기, 나머지 연산에서는 문자형 자료를 모두 숫자로 자동 인식함

> 예제 : 할인 가격 계산 프로그램

```
<script>
	function showPrice( ) {
    	var originPrice = document.querySelector('#oPrice').value;
    	var rate = document.querySelector('#rate').value;
    	var savedPrice = originPrice * (rate/100);
    	var resultPrice = originPrice - savePrice;
    	document.querySelector('#showResult').innerHTML = '원가격 '+originPrice +'원, 할인율' + rate + '이며, 할인금액 ' + savedPrice + '원으로 최종가 '+ resultPrice + '입니다.'
	}    
</script>
```

### 조건문 if

**if 문**

괄호 안의 조건이 true이면 { } 사이의 명령을 처리하고, false 이면 { } 안의 명령 무시

**if … else 문**

if( ) 문의 괄호 안의 조건이 true이면 if 다음에 있는 { }의 명령을 처리하고,

false 이면 else 다음에 있는 { } 안의 명령 실행

**조건 연산자**

조건이 하나이고 실행할 명령도 하나일 때 `(조건)? 명령1 : 명령2` -> 삼항 연산자라고도 부름\

```
var score = 75;
(score >= 60)? alert("통과") : alert("실패");
// 60이상에서 통과 그외는 실패
// 75이므로 통과
```

> 예제 : 3의 배수 검사기

```
<script>
	var userNumber = prompt("숫자를 입력하세요 : ");
	var displayArea = document.querySelector('#result');
	if(userNumber != null) {
        if (userNumber % 3 === 0){
        	displayArea.innerHTML = userNumber + "은 3의배수입니다.";
    }
	else {
        displayArea.innerHTML = userNumber + "은 3의배수가 아닙니다.";
    }
}
</script>
```

> 예제 : switch문으로 여러 조건 값 확인하기

```
<script>
		var session = prompt("관심 세션을 선택해 주세요. 1-마케팅, 2-개발, 3-디자인", "1");
	switch(session) {
        case "1" : document.write("<p>마케팅 세션은 <strong>201</strong>호입니다.</p>");
            break;
        case "2" : document.write("<p>개발 세션은 <strong>202</strong>호입니다.</p>");;
            break;
        case "3" : document.write("<p>디자인 세션은 <strong>203</strong>호입니다.</p>");;
            break;
        default: alert("잘못 입력했습니다.");
    }
</script>
```

[조건문 예제1](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-1.html) [조건문 예제2](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-2.html) [조건문 예제3](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-3.html) [조건문 예제4](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-4.html) [조건문 예제5](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-5.html) [조건문 예제6](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/if-6.html) [switch문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/switch.html)

### 반복문 for

- 카운터 변수를 기준으로 명령을 여러 번 실행

  ```
  for (initialization; condition; expression) {
      // do sth
  }
  // initialization : 최초 반복문 진입 시 1회만 실행되는 부분
  // condition      : 매 반복 시행 전 평가되는 부분
  // expression     : 매 반복 시행 이후 평가되는 부분
  ```

- 여러 명령을 늘어 놓지 않고 소스를 간단하게 작성할 수 있음

- 소스의 양이 줄어 실행 속도가 빨라짐

- for ... of

  - 반복 가능한 객체(Array, Map, Set, String 등)를 순회하며 값을 꺼낼때 사용

- for ... in

  - 주로 객체(Object)의 속성들을 순회할 때 사용
  - 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않음

  ```
  var sum = 0;
  sum += 1;
  sum += 2;
  sum += 3;
  sum += 4;
  sum += 5;
  document.write("1부터 5까지 더하면 "+ sum);
  ```

  for사용시 아래같이 압축됨

  ```
  var sum = 0;
  for(var i = 1; i < 6; i++) {
      sum += i;
  }
  document.write("1부터 5까지 더하면 "+ sum);
  ```

  > 예제 : 구구단 프로그램

  ```
  //1번 방법
  for(var i=2; i<=9; i++) {
      document.write("<div>");
      for(var j=1; j<=9; j++) {
          document.write(i + "X" + j "=" + i*j + "<br>");
      }
      document.write("</div>");
  }
  ```

[for문 예제1](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/for-1.html) [for문 예제2](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/for-2.html) [for문 예제3](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/for-3.html) [for문 예제4](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/for-4.html) [for문 예제5](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/for-5.html) [중첩 for문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/double-for-1.html)

### 반복문 while, do while

> 반복 횟수 기준이라면 for 문을 쓰고 특정 조건에 따라 반복한다면 while문이나 do while문 사용

- 형식

```
//while문
var i = 0;
while(i<10) {
    document.write('반복 조건이 true이면 반복합니다. <br>');
    i += 1;
}
//do while문
var i = 0;
do {
    document.write('반복 조건이 true이면 반복하며 초기값에 관계없이 무조건 1회 시행합니다. <br>');
    i+=1;
}while (i< 10);
```

> 예제 : 팩토리얼 계산 프로그램

```
var n = prompt("숫자를 입력하세요.");
var nFact = 1;
var i = 2;
while (i <= n) {
    nFact *= i;
    i++;
}
document.write(n + "! = " +nFact);
```

[while문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/while.html) [무한while문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/while-unlimited.html) [do while문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/do-while.html) [do while문 예제2](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/do-while-user.html)

#### 반복 제어

- break문
  - 반복문의 흐름에서 바로 빠져나올 때 사용
- continue문
  - 주어진 조건에 맞는 값을 만났을 때 실행하던 반복 문장을 건너뛰고 반복문의 맨 앞으로 되돌아 감

[continue문 예제](https://github.com/kangdh208/TIL/blob/master/9week/ES6/Example/continue.html)

### 함수

- 참조 타입 중 하나로써 function 타입에 속함
- JavaScript에서 함수를 정의하는 방법은 주로 2가지로 구분
  - 함수 선언식 (function declaration)
  - 함수 표현식 (function expression)
- JavaScript의 함수는 일급 객체(First-class citizen)에 해당
  - 일급 객체: 다음의 조건들을 만족하는 객체를 의미함
    - 변수에 할당 가능
    - 함수의 매개변수로 전달 가능
    - 함수의 반환 값으로 사용 가능

##### 함수의 정의

- 함수의 이름과 함께 정의

- 이름(name) , 매개변수(args) , 함수 body(중괄호 내부)

  ```
  function name(args) {
      // do sth
  };
  // 예시
  function add(num1, num2) {
      return num1 + num2;
  };
  ```

##### 함수 표현식

- 함수를 표현식(어떤 하나의 값으로 결정되는 코드의단위)내에서 정의하는 방식

- 익명함수(이름의 없는 함수) 로 정의 가능 >> 함수 표현식에서만 가능

- 인자 작성시 '=' 문자 뒤 기본 인자 선언 가능

  ```
  const greeting = function (name = 'Anonymous') {
      return `Hi ${name}`
  };
  
  greeting() // Hi Anonymous
  ```

- 매개변수와 인자의 개수 불일치 허용

  - 매개변수 < 인자

    ```
    const noArgs = function () {
        return 0;
    };
    
    noArgs(1, 2, 3); // 0
    
    const twoArgs = function (arg1, arg2) {
        return[arg1, arg2];
    };
    
    twoArgs(1, 2, 3) // [1, 2]
    ```

  - 매개변수 > 인자

    ```
    const threeArgs = function(arg1, arg2, arg3) {
        return [arg1, arg2, arg3];
    };
    
    threeArgs()      // [undefined, undefined, undefined]
    threeArgs(1)     // [1, undefined, undefined]
    threeArgs(1, 2)  // [1, 2, undefined]
    ```

##### Rest Parameter

- rest parameter(…)를 사용하면 함수가 정해지지 않은 수의 매개변수를 배열로 받음

  - 만약 rest parameter로 처리한 매개변수에 인자가 넘어오지 않을 경우에는, 빈 배열로 처리

    ```
    const restOper = function (arg1, arg2, ...restArgs) {
        return [arg1, arg2, restArgs];
    };
    
    restArgs(1, 2, 3, 4, 5) // [1, 2, [3, 4, 5]]
    restArgs(1, 2)          // [1, 2, []]
    ```

##### Spread Operator

- spread operator(…)를 사용하면 배열 인자를 전개하여 전달 가능

  ```
  const spreadOpr = function (arg1, arg2, arg3) {
      return arg1 + arg2 + arg3;
  };
  
  const numbers = [1, 2, 3];
  spreadOpr(...numbers) //6
  ```

##### 함수의 타입

- 선언식 함수와 표현식 함수 모두 타입은 function으로 동일

  ```
  // 함수 표현식
  const add = function (args) {};
  
  // 함수 선언식
  function sub(args) {};
  
  console.log(typeof add); // function
  console.log(typeof sub); // function
  ```

  - 함수선언식으로 선언한 함수는 var로 정의한 변수처럼 hoisting 발생

    - 함수 호출 이후에 선언해도 동작

      ```
      add(2, 7) // 9
      
      fucntion add (num1, num2) {
          return num1 + num2
      }
      ```

  - 함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러 발생

    - 함수 표현식으로 정의된 함수는 변수로 평가되어 변수의 scope 규칙을 따름

      ```
      sub(7, 2) // Uncaught ReferenceError: Cannot access 'sub' before initialization
      
      const sub = function(num1, num2) {
          return num1 - num2
      }
      ```